## 서버의 복수 동시접속 처리

서버는 동시에 여러 클라이언트 처리 필요

동시에 사용자 몰리면 기다림 blocking
accept()/connect()/recv()/send() blocking

처리 방법 3가지
1. 멀티 쓰레딩
	소켓 별로 처리 쓰레드 두게 함
	별로
1. Non-blocking I/O
	poling
	루프 만 번을 돌아야 하는 문제 생김
1. I/O multiplexing
	이벤트가 있는 경우만 동작

## I/O Multiplexing
메가박스 처음 나왔을 때 멀티플렉스 관이라 함
관 여러 개를 묶어놨다 해서 멀티플렉스라 함
## select() 함수

소켓이 끊기면 readfds로 확인
readfds를 가장 많이 쓴다
fd_set은 내부적으로 다루는 타입(opaque)

## select() 함수의 fd_set
typedef 되어있는 구조체임 -> 사실 몰라도 됨
그냥 타입인가보다 생각하면 된다



## select() 이벤트 종류 및 예시 코드

readset writeset 두 개 많이 사용



## select() 함수의 fd_set

내부적으로 비트로 관리하는 배열이 있다(그냥 배열이 있다고 생각하면 됨)
## select() 의 timeout 시간

마지막 인자는 시간
null -> 이벤트 하나라도 발생할 때까지 대기함. blocking 모드

뭐가 오든 간에 무조건 기다릴거야는 null

해야할 것 있고 timeout 둘거면 마지막 인자 시간 지정해준다
<mark style="background: #BBFABBA6;">아예 0을 넣어서 딴 것 처리하게 하기도?</mark>

## 예제 코드

서버 소켓이 남아있으면 accept하면 됨
## select() 의 한계

다룰 수 있는 소켓 한정적임

코드에서도 봐서 알겠지만 클라이언트 소켓은 loop를 돌음
대안으로 os별로 처리하는 것들이 있다

## select() 의 대안


## Blocking Call vs. Non-blocking Call

단순히 시간이 오래 결린다고 blocking call이 아님

아무것도 안하고 있으니 throughput도 작아짐

## Polling & Busy Wait

polling으로 계속 작업 끝났는지 체크함 -> 계속 loop를 돌기 때문에 busy wait
polling은 물어보는 것임. 효율적으로 처리하면 busy wait이 아님
loop 도는 것은 cpu를 사용하기 때문에 busy wait이다.

## 서버의 적정 CPU 사용률

의미있는 작업을 단위 시간당 몇 개 하느냐 => throughput가 굿

## Non-blocking 예제 코드

다음 시간에 설명